'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const DEFAULT_REQUEST_TIMEOUT = 1000 * 60; // 30 seconds

/**
 * Class to communicate with the outside world.
 * Wraps around fetch.
 * @private
 */
class Http {
	/**
  * @param {Number} [requestTimeout=DEFAULT_REQUEST_TIMEOUT] A time in ms
  * after the start of a request when it should be timed out.
  */
	constructor(requestTimeout = DEFAULT_REQUEST_TIMEOUT) {
		/**
   * @type {Object}
   * @private
   * @readonly
   */
		this._ratelimit = {
			queue: [],
			timeoutId: undefined
			/**
    * @type {String}
    * @private
    */
		};this._token = '';
		/**
   * @type {Number}
   * @private
   * @readonly
   */
		this._requestTimeout = requestTimeout;
	}

	/**
  * @private
  * @param {Object} request
  */
	_enqueue(request) {
		return new Promise((resolve, reject) => {
			this._ratelimit.queue.push({
				request,
				resolve,
				reject
			});
		});
	}
	/**
  * @private
  * @param {Number} timeLeft time left for the ratelimit in seconds.
  */
	_setRatelimitTime(timeLeft) {
		const info = this._ratelimit;
		if (info.timeoutId !== undefined) {
			return;
		}

		info.timeoutId = setInterval(() => {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = info.queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					const item = _step.value;

					(0, _nodeFetch2.default)(item.request).then(item.resolve, item.reject);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			info.queue = [];
			info.timeoutId = undefined;
		}, timeLeft * 1000 + 10);
	}

	/**
  * @param {Object} obj
  * @return {Request}
  */
	makeRequest(obj) {
		const init = {
			method: obj.method,
			timeout: this._requestTimeout,
			headers: _extends({}, obj.headers, {
				Authorization: 'Bearer ' + this._token,
				'X-API-Client-ID': '12D8'
			}),
			redirect: obj.redirect
		};

		if (obj.data != null) {
			init.body = JSON.stringify(obj.data);
			init.headers['Content-Type'] = 'application/json;charset=UTF-8';
		}

		return new _nodeFetch2.default.Request(obj.url, init);
	}

	/**
  * @private
  * @param {Object} obj
  */
	_request(obj) {
		var _this = this;

		return _asyncToGenerator(function* () {
			const request = _this.makeRequest(obj);
			const info = _this._ratelimit;

			let res;
			if (info.timeoutId === undefined) {
				res = yield (0, _nodeFetch2.default)(request);
			} else {
				res = yield _this._enqueue(request);
			}

			if (res.ok || res.status === 302) {
				return res;
			}

			try {
				const body = yield res.body();
				const parsed = JSON.parse(body);
				if ('SecondsLeft' in parsed) {
					// Handle rate limit errors
					_this._setRatelimitTime(Number.parseInt(parsed.SecondsLeft, 10));
					return _this._request(obj);
				}
			} catch (_) {
				return res;
			}
		})();
	}

	/**
  * Gets the content at `url`
  * @param {String} url
  * @param {Object} [opt]
  * @return {Promise<Response>}
  */
	get(url, opt) {
		return this._request(_extends({}, opt, {
			method: 'get',
			url: url
		}));
	}

	/**
  * Posts the given `data` to `url`
  * @param {String} url
  * @param {Object} [data]
  * @param {Object} [opt]
  * @return {Promise<Response>}
  */
	post(url, data, opt) {
		return this._request(_extends({}, opt, {
			method: 'post',
			url: url,
			data: data
		}));
	}

	/**
  * Puts the given `data` to `url`
  * @param {String} url
  * @param {Object} [data]
  * @param {Object} [opt]
  * @return {Promise<Response>}
  */
	put(url, data, opt) {
		return this._request(_extends({}, opt, {
			method: 'put',
			url: url,
			data: data
		}));
	}

	/**
  * Deletes the content at `url`
  * @param {String} url
  * @return {Promise<Response>}
  */
	delete(url) {
		return this._request({
			method: 'delete',
			url: url
		});
	}
}

exports.default = Http;
