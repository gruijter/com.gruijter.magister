'use strict'; // external

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = magister;
exports.getSchools = getSchools;
Object.defineProperty(exports, "AbsenceInfo", {
  enumerable: true,
  get: function () {
    return _absenceInfo.default;
  }
});
Object.defineProperty(exports, "Activity", {
  enumerable: true,
  get: function () {
    return _activity.default;
  }
});
Object.defineProperty(exports, "Appointment", {
  enumerable: true,
  get: function () {
    return _appointment.default;
  }
});
Object.defineProperty(exports, "Assignment", {
  enumerable: true,
  get: function () {
    return _assignment.default;
  }
});
Object.defineProperty(exports, "AuthError", {
  enumerable: true,
  get: function () {
    return _authError.default;
  }
});
Object.defineProperty(exports, "Class", {
  enumerable: true,
  get: function () {
    return _class.default;
  }
});
Object.defineProperty(exports, "Course", {
  enumerable: true,
  get: function () {
    return _course.default;
  }
});
Object.defineProperty(exports, "FileFolder", {
  enumerable: true,
  get: function () {
    return _fileFolder.default;
  }
});
Object.defineProperty(exports, "MessageFolder", {
  enumerable: true,
  get: function () {
    return _messageFolder.default;
  }
});
Object.defineProperty(exports, "Person", {
  enumerable: true,
  get: function () {
    return _person.default;
  }
});
Object.defineProperty(exports, "Privileges", {
  enumerable: true,
  get: function () {
    return _privileges.default;
  }
});
Object.defineProperty(exports, "ProfileInfo", {
  enumerable: true,
  get: function () {
    return _profileInfo.default;
  }
});
Object.defineProperty(exports, "School", {
  enumerable: true,
  get: function () {
    return _school.default;
  }
});
Object.defineProperty(exports, "SchoolUtility", {
  enumerable: true,
  get: function () {
    return _schoolUtility.default;
  }
});
Object.defineProperty(exports, "ActivityElement", {
  enumerable: true,
  get: function () {
    return _activityElement.default;
  }
});
Object.defineProperty(exports, "AddressInfo", {
  enumerable: true,
  get: function () {
    return _addressInfo.default;
  }
});
Object.defineProperty(exports, "AssignmentVersion", {
  enumerable: true,
  get: function () {
    return _assignmentVersion.default;
  }
});
Object.defineProperty(exports, "File", {
  enumerable: true,
  get: function () {
    return _file.default;
  }
});
Object.defineProperty(exports, "Grade", {
  enumerable: true,
  get: function () {
    return _grade.default;
  }
});
Object.defineProperty(exports, "GradePeriod", {
  enumerable: true,
  get: function () {
    return _gradePeriod.default;
  }
});
Object.defineProperty(exports, "GradeType", {
  enumerable: true,
  get: function () {
    return _gradeType.default;
  }
});
Object.defineProperty(exports, "Message", {
  enumerable: true,
  get: function () {
    return _message.default;
  }
});
Object.defineProperty(exports, "ProfileSettings", {
  enumerable: true,
  get: function () {
    return _profileSettings.default;
  }
});
Object.defineProperty(exports, "VersionInfo", {
  enumerable: true,
  get: function () {
    return _versionInfo.default;
  }
});
exports.Magister = exports.VERSION = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _url = _interopRequireDefault(require("url"));

var _authcode = _interopRequireDefault(require("@magisterjs/authcode"));

var _absenceInfo = _interopRequireDefault(require("./absenceInfo"));

var _activity = _interopRequireDefault(require("./activity"));

var _appointment = _interopRequireDefault(require("./appointment"));

var _assignment = _interopRequireDefault(require("./assignment"));

var _authError = _interopRequireDefault(require("./authError"));

var _class = _interopRequireDefault(require("./class"));

var _course = _interopRequireDefault(require("./course"));

var _fileFolder = _interopRequireDefault(require("./fileFolder"));

var _http = _interopRequireDefault(require("./http"));

var _messageFolder = _interopRequireDefault(require("./messageFolder"));

var _person = _interopRequireDefault(require("./person"));

var _privileges = _interopRequireDefault(require("./privileges"));

var _profileInfo = _interopRequireDefault(require("./profileInfo"));

var _school = _interopRequireDefault(require("./school"));

var _schoolUtility = _interopRequireDefault(require("./schoolUtility"));

var util = _interopRequireWildcard(require("./util"));

var _activityElement = _interopRequireDefault(require("./activityElement"));

var _addressInfo = _interopRequireDefault(require("./addressInfo"));

var _assignmentVersion = _interopRequireDefault(require("./assignmentVersion"));

var _file = _interopRequireDefault(require("./file"));

var _grade = _interopRequireDefault(require("./grade"));

var _gradePeriod = _interopRequireDefault(require("./gradePeriod"));

var _gradeType = _interopRequireDefault(require("./gradeType"));

var _message = _interopRequireDefault(require("./message"));

var _profileSettings = _interopRequireDefault(require("./profileSettings"));

var _versionInfo = _interopRequireDefault(require("./versionInfo"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// internal: used in this file
// internal: only being exported
// TODO: add nice warnings when trying to do stuff while not logged in yet

/**
 * Class to communicate with Magister.
 */
class Magister {
  /**
   * @private
   * @param {Object} options
   * @param {School} school
   * @param {Http} http
   */
  constructor(options, school, http) {
    const info = _url.default.parse(school.url);

    if (!/^[^.#/\\]+\.magister\.net$/.test(info.host)) {
      throw new Error('`school.url` is not a correct magister url');
    }

    school.url = `https://${info.host}`;
    /**
     * @type {Object}
     * @readonly
     * @private
     */

    this._options = options;
    /**
     * @type {School}
     * @readonly
     */

    this.school = _lodash.default.extend(new _school.default({}), school);
    /**
     * @type {Http}
     * @readonly
     */

    this.http = http;
    /**
     * @type {ProfileInfo}
     * @readonly
     */

    this.profileInfo = null;
  }
  /**
  	 * @type {string}
  	 * @readonly
  	 */


  get token() {
    return this.http._token;
  }
  /**
   * @returns {Promise<Activity[]>}
   */


  activities() {
    return this._privileges.needs('activiteiten', 'read').then(() => this.http.get(`${this._personUrl}/activiteiten`)).then(res => res.json()).then(res => res.Items.map(a => new _activity.default(this, a)));
  }
  /**
   * @param {Date} from Time is ignored.
   * @param {Date} [to=from] Time is ignored
   * @param {Object} [options={}]
   * 	@param {boolean} [options.fillPersons=false]
   * 	@param {boolean} [options.fetchAbsences=true]
   * 	@param {boolean} [options.ignoreAbsenceErrors=true]
   * @returns {Promise<Appointment[]>}
   */


  appointments() {
    // extract options
    const {
      fillPersons = false,
      fetchAbsences = true,
      ignoreAbsenceErrors = true
    } = _lodash.default.find(arguments, _lodash.default.isPlainObject) || {}; // extract dates

    const dates = (0, _lodash.default)(arguments).filter(_lodash.default.isDate).sortBy().value();
    const from = dates[0];
    const to = dates[1] || dates[0];
    const fromUrl = util.urlDateConvert(from);
    const toUrl = util.urlDateConvert(to); // fetch appointments

    const appointmentsUrl = `${this._personUrl}/afspraken?van=${fromUrl}&tot=${toUrl}`;

    const appointmentsPromise = this._privileges.needs('afspraken', 'read').then(() => this.http.get(appointmentsUrl)).then(res => res.json()).then(res => res.Items.map(a => new _appointment.default(this, a))).then(appointments => {
      if (!fillPersons) {
        return appointments;
      }

      const promises = appointments.map(a => {
        return Promise.all(a.teachers.map(t => t.getFilled('teacher'))).then(teachers => a.teachers = teachers).then(() => a);
      });
      return Promise.all(promises);
    }); // fetch absences


    let absencesPromise = Promise.resolve([]);

    if (fetchAbsences) {
      const absencesUrl = `${this._personUrl}/absenties?van=${fromUrl}&tot=${toUrl}`;
      absencesPromise = this._privileges.needs('Absenties', 'read').then(() => this.http.get(absencesUrl)).then(res => res.json()).then(res => res.Items.map(a => new _absenceInfo.default(this, a)));

      if (ignoreAbsenceErrors) {
        absencesPromise = absencesPromise.catch(() => []);
      }
    }

    return Promise.all([appointmentsPromise, absencesPromise]).then(([appointments, absences]) => {
      for (const a of appointments) {
        a.absenceInfo = absences.find(i => i.appointment.id === a.id);
      }

      return appointments;
    }).then(appointments => _lodash.default.sortBy(appointments, 'start'));
  }
  /**
   * @param {Object} [options={}]
   * 	@param {number} [options.count=50]
   * 	@param {number} [options.skip=0]
   * 	@param {boolean} [options.fillPersons=false]
   * @returns {Promise<Assignment[]>}
   */


  assignments({
    count = 50,
    skip = 0,
    fillPersons = false
  } = {}) {
    const url = `${this._personUrl}/opdrachten?top=${count}&skip=${skip}&status=alle`;
    return this._privileges.needs('eloopdracht', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(i => i.Id)).then(ids => {
      const promises = ids.map(id => {
        return this.http.get(`${this._personUrl}/opdrachten/${id}`).then(res => res.json());
      });
      return Promise.all(promises);
    }).then(items => {
      const promises = items.map(item => {
        const assignment = new _assignment.default(this, item);

        if (!fillPersons) {
          return assignment;
        }

        return Promise.all(assignment.teachers.map(p => p.getFilled('teacher'))).then(teachers => assignment.teachers = teachers).then(() => assignment);
      });
      return Promise.all(promises);
    });
  }
  /**
   * @returns {Promise<Magister[]>}
   */


  children() {
    if (this.profileInfo.isChild) {
      return Promise.reject(new Error('User is not a parent'));
    }

    return this.http.get(`${this._personUrl}/kinderen`).then(res => res.json()).then(res => res.Items).then(items => items.map(raw => {
      const m = Object.create(this);
      m.school = this.school;
      m.http = this.http;
      m._personUrl = `${this.school.url}/api/personen/${raw.Id}`;
      m._pupilUrl = `${this.school.url}/api/leerlingen/${raw.Id}`;
      m.profileInfo = new _profileInfo.default(m, raw);
      return m;
    }));
  }
  /**
   * @returns {Promise<Course[]>}
   */


  courses() {
    return this._privileges.needs('aanmeldingen', 'read').then(() => this.http.get(`${this._personUrl}/aanmeldingen`)).then(res => res.json()).then(res => res.Items.map(c => new _course.default(this, c))).then(items => _lodash.default.sortBy(items, 'start'));
  }
  /**
   * @param {Object} options
   * 	@param {string} options.description The description of the appointment.
   * 	@param {Date} options.start The start of the appointment, time is
   * 	ignored when `options.fullDay` is set to true.
   * 	@param {Date} options.end The end of the appointment, this is ignored
   * 	when `options.fullDay` is set to true.
   * 	@param {boolean} [options.fullDay=false] When this is true,
   * 	`options.end` is ignored and only `options.start` is used to set the
   * 	begin and the end for the appointment.
   * 	@param {string} [options.location] The location (classroom for example)
   * 	for the appointment.
   * 	@param {string} [options.content] Some arbitrary string you want to
   * 	save.
   * 	@param {number} [options.type=1] The type of the appointment: 1 for
   * 	personal or 16 for planning
   * @returns {Promise}
   */


  createAppointment(options) {
    const required = ['description', 'start', 'end'];

    for (const key of required) {
      if (options[key] == null) {
        const err = new Error(`Not all required fields for \`options\` are given, required are: [ ${required.join(', ')} ]`);
        return Promise.reject(err);
      }
    }

    if (options.fullDay) {
      options.start = util.date(options.start);
      options.end = new Date(options.start.getTime()) + 1000 * 60 * 60 * 24;
    }

    let content = _lodash.default.trim(options.content);

    content = content.length > 0 ? _lodash.default.escape(content) : null;
    const payload = {
      Omschrijving: options.description,
      Start: options.start.toJSON(),
      Einde: options.end.toJSON(),
      Lokatie: _lodash.default.trim(options.location),
      Inhoud: content,
      Type: options.type || 1,
      DuurtHeleDag: options.fullDay || false,
      InfoType: content === null ? 0 : 6,
      // Static non-configurable stuff.
      WeergaveType: 1,
      Status: 2,
      HeeftBijlagen: false,
      Bijlagen: null,
      LesuurVan: null,
      LesuurTotMet: null,
      Aantekening: null,
      Afgerond: false,
      Vakken: null,
      Docenten: null,
      Links: null,
      Id: 0,
      Lokalen: null,
      Groepen: null,
      OpdrachtId: 0
    };
    return this._privileges.needs('afspraken', 'create').then(() => this.http.post(`${this._personUrl}/afspraken`, payload));
  }
  /**
   * @param {Integer} [parentId = 0]
   * @returns {Promise<FileFolder[]>}
   */


  fileFolders(parentId = 0) {
    return this._privileges.needs('bronnen', 'read').then(() => {
      let url = `${this._personUrl}/bronnen?soort=0`;

      if (parentId !== 0) {
        url += `&parentId=${parentId}`;
      }

      return this.http.get(url);
    }).then(res => res.json()).then(res => {
      return res.Items.filter(item => ![0, 1, 2, 4].includes(item.Type)).map(f => new _fileFolder.default(this, f));
    });
  }
  /**
   * @returns {Promise<MessageFolder[]>}
   */


  messageFolders() {
    return this._privileges.needs('berichten', 'read').then(() => this.http.get(`${this._personUrl}/berichten/mappen`)).then(res => res.json()).then(res => res.Items.map(m => new _messageFolder.default(this, m)));
  }
  /**
   * @param {string} query
   * @param {string} [type]
   * @returns {Promise<Person[]>}
   */


  persons(query, type) {
    query = query != null ? query.trim() : '';

    if (query.length < 3) {
      return Promise.resolve([]);
    } else if (type == null) {
      return Promise.all([this.persons(query, 'teacher'), this.persons(query, 'pupil')]).then(([teachers, pupils]) => teachers.concat(pupils));
    }

    type = {
      'teacher': 'Personeel',
      'pupil': 'Leerling',
      'project': 'Project'
    }[type] || 'Overig';
    query = query.replace(/ +/g, '+');
    const url = `${this._personUrl}/contactpersonen?contactPersoonType=${type}&q=${query}`;
    return this._privileges.needs('contactpersonen', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(p => {
      p = new _person.default(this, p);
      p._filled = true;
      return p;
    }));
  }
  /**
   * @returns {Promise<SchoolUtility[]>}
   */


  schoolUtilities() {
    const url = `${this._personUrl}/lesmateriaal`;
    return this._privileges.needs('digitaallesmateriaal', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(u => new _schoolUtility.default(this, u)));
  }
  /**
   * Logins to Magister.
   * @param {boolean} [forceLogin=false] Force a login, even when a token
   * is in the options object.
   * @returns {Promise<string>} A promise that resolves when done logging in. With the current session ID as parameter.
   */


  async login(forceLogin = false) {
    // TODO: clean this code up a bit
    const self = this;
    const options = this._options;
    const schoolUrl = this.school.url;
    const filteredName = schoolUrl.replace('https://', '');
    let authorizeUrl = 'https://accounts.magister.net/connect/authorize';
    authorizeUrl += `?client_id=M6-${filteredName}`;
    authorizeUrl += `&redirect_uri=https%3A%2F%2F${filteredName}%2Foidc%2Fredirect_callback.html`;
    authorizeUrl += '&response_type=id_token%20token';
    authorizeUrl += '&scope=openid%20profile%20magister.ecs.legacy%20magister.mdv.broker.read%20magister.dnn.roles.read';
    authorizeUrl += `&state=${await util.randomHex()}`;
    authorizeUrl += `&nonce=${await util.randomHex()}`;
    authorizeUrl += `&acr_values=tenant%3A${filteredName}`;

    const setToken = token => {
      self.http._token = token;
      return token;
    };

    const retrieveAccount = async () => {
      const accountData = await self.http.get(`${schoolUrl}/api/account`).then(res => res.json());
      const id = accountData.Persoon.Id;
      self._personUrl = `${schoolUrl}/api/personen/${id}`;
      self._pupilUrl = `${schoolUrl}/api/leerlingen/${id}`;
      self._privileges = new _privileges.default(self, accountData.Groep[0].Privileges); // REVIEW: do we want to make profileInfo a function?

      self.profileInfo = new _profileInfo.default(self, accountData.Persoon, (await self._privileges.can('kinderen', 'read')));
    };

    if (!forceLogin && options.token) {
      setToken(options.token);
      return await retrieveAccount();
    } // extract returnUrl


    const location = await this.http.get(authorizeUrl, {
      redirect: 'manual'
    }).then(res => res.headers.get('Location'));
    const returnUrl = decodeURIComponent(location.split('returnUrl=')[1]); // extract session and XSRF related stuff

    const xsrfResponse = await this.http.get(location, {
      redirect: 'manual'
    });
    const authUrl = 'https://accounts.magister.net/challenge';
    let sessionId;
    let xsrf;
    let authCookies;

    try {
      sessionId = xsrfResponse.headers.get('Location').split('?')[1].split('&')[0].split('=')[1];
      xsrf = xsrfResponse.headers.get('set-cookie').split('XSRF-TOKEN=')[1].split(';')[0];
      authCookies = xsrfResponse.headers.get('set-cookie').toString();
    } catch (err) {
      if (err.message === 'Cannot read property \'split\' of null') {
        throw new _authError.default('Invalid school url');
      } else {
        throw err;
      }
    }

    let authRes; // test username

    authRes = await this.http.post(`${authUrl}/username`, {
      authCode: options.authCode,
      sessionId: sessionId,
      returnUrl: returnUrl,
      username: options.username
    }, {
      headers: {
        Cookie: authCookies,
        'X-XSRF-TOKEN': xsrf
      }
    });

    if (authRes.error || authRes.status !== 200) {
      throw new _authError.default(authRes.error || 'Invalid username');
    } // test password


    authRes = await this.http.post(`${authUrl}/password`, {
      authCode: options.authCode,
      sessionId: sessionId,
      returnUrl: returnUrl,
      password: options.password
    }, {
      headers: {
        Cookie: authCookies,
        'X-XSRF-TOKEN': xsrf
      }
    });

    if (authRes.error || authRes.status !== 200) {
      throw new _authError.default(authRes.error || 'Invalid password');
    } // extract bearer token


    const res = await this.http.get(`https://accounts.magister.net${returnUrl}`, {
      redirect: 'manual',
      headers: {
        Cookie: authRes.headers.get('set-cookie'),
        'X-XSRF-TOKEN': xsrf
      }
    });
    const tokenRegex = /&access_token=([^&]*)/;
    const loc = res.headers.get('Location');
    setToken(tokenRegex.exec(loc)[1]);
    return await retrieveAccount();
  }

}
/**
 * Create a new Magister object using `options`.
 * @param {Object} options
 * 	@param {School} options.school The school to login to.
 * 	@param {string} [options.username] The username of the user to login to.
 * 	@param {string} [options.password] The password of the user to login to.
 * 	@param {string} [options.token] The Bearer token to use. (instead of the username and password)
 * 	@param {boolean} [options.keepLoggedIn=true] Whether or not to keep the user logged in.
 * 	@param {boolean} [options.login=true] Whether or not to call {@link login} before returning the object.
 * 	@param {string} [options.authCode=AuthCode] The AuthCode that Magister uses in their
 * 	requests. Per default we use the value from the @magisterjs/authcode
 * 	package. Which you should keep up-to-date.
 * @returns {Promise<Magister>}
 */


exports.Magister = Magister;

function magister(options) {
  _lodash.default.defaults(options, {
    keepLoggedIn: true,
    login: true,
    authCode: _authcode.default
  });

  const rej = s => Promise.reject(new Error(s));

  if (!(options.school && (options.token || options.username && options.password))) {
    return rej('school and username&password or token are required.');
  }

  if (!_lodash.default.isObject(options.school)) {
    return rej('school is not an object');
  } else if (!_lodash.default.isString(options.school.url)) {
    return rej('`school.url` is not a string');
  }

  return Promise.resolve().then(() => {
    const m = new Magister(options, options.school, new _http.default());
    return options.login ? m.login().then(() => m) : m;
  });
}
/**
 * Get the schools matching `query`.
 * @param {string} query
 * @returns {Promise<School[]>}
 */


function getSchools(query) {
  query = query.replace(/\d/g, '');
  query = query.trim();
  query = query.replace(/ +/g, '+');

  if (query.length < 3) {
    return Promise.resolve([]);
  }

  return (0, _nodeFetch.default)(`https://mijn.magister.net/api/schools?filter=${query}`).then(res => res.json()).then(schools => schools.map(school => new _school.default(school)));
}
/**
 * The version of the library.
 * @type {String}
 * @readonly
 */


const VERSION = "2.0.0-alpha.12";
exports.VERSION = VERSION;