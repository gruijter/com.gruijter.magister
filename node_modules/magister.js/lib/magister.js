'use strict';

// external

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.VersionInfo = exports.SchoolUtility = exports.School = exports.ProfileSettings = exports.ProfileInfo = exports.Privileges = exports.Person = exports.MessageFolder = exports.Message = exports.Magister = exports.GradeType = exports.GradePeriod = exports.Grade = exports.FileFolder = exports.File = exports.Course = exports.Class = exports.AuthError = exports.AssignmentVersion = exports.Assignment = exports.Appointment = exports.AddressInfo = exports.ActivityElement = exports.Activity = exports.AbsenceInfo = exports.VERSION = undefined;
exports.default = magister;
exports.getSchools = getSchools;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _crypto = require('crypto');

var _absenceInfo = require('./absenceInfo');

var _absenceInfo2 = _interopRequireDefault(_absenceInfo);

var _activity = require('./activity');

var _activity2 = _interopRequireDefault(_activity);

var _appointment = require('./appointment');

var _appointment2 = _interopRequireDefault(_appointment);

var _assignment = require('./assignment');

var _assignment2 = _interopRequireDefault(_assignment);

var _authError = require('./authError');

var _authError2 = _interopRequireDefault(_authError);

var _class = require('./class');

var _class2 = _interopRequireDefault(_class);

var _course = require('./course');

var _course2 = _interopRequireDefault(_course);

var _fileFolder = require('./fileFolder');

var _fileFolder2 = _interopRequireDefault(_fileFolder);

var _http = require('./http');

var _http2 = _interopRequireDefault(_http);

var _messageFolder = require('./messageFolder');

var _messageFolder2 = _interopRequireDefault(_messageFolder);

var _person = require('./person');

var _person2 = _interopRequireDefault(_person);

var _privileges = require('./privileges');

var _privileges2 = _interopRequireDefault(_privileges);

var _profileInfo = require('./profileInfo');

var _profileInfo2 = _interopRequireDefault(_profileInfo);

var _school = require('./school');

var _school2 = _interopRequireDefault(_school);

var _schoolUtility = require('./schoolUtility');

var _schoolUtility2 = _interopRequireDefault(_schoolUtility);

var _util = require('./util');

var util = _interopRequireWildcard(_util);

var _activityElement = require('./activityElement');

var _activityElement2 = _interopRequireDefault(_activityElement);

var _addressInfo = require('./addressInfo');

var _addressInfo2 = _interopRequireDefault(_addressInfo);

var _assignmentVersion = require('./assignmentVersion');

var _assignmentVersion2 = _interopRequireDefault(_assignmentVersion);

var _file = require('./file');

var _file2 = _interopRequireDefault(_file);

var _grade = require('./grade');

var _grade2 = _interopRequireDefault(_grade);

var _gradePeriod = require('./gradePeriod');

var _gradePeriod2 = _interopRequireDefault(_gradePeriod);

var _gradeType = require('./gradeType');

var _gradeType2 = _interopRequireDefault(_gradeType);

var _message = require('./message');

var _message2 = _interopRequireDefault(_message);

var _profileSettings = require('./profileSettings');

var _profileSettings2 = _interopRequireDefault(_profileSettings);

var _versionInfo = require('./versionInfo');

var _versionInfo2 = _interopRequireDefault(_versionInfo);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// internal: used in this file


// internal: only being exported


// TODO: add nice warnings when trying to do stuff while not logged in yet

/**
 * Class to communicate with Magister.
 */
class Magister {
	/**
  * @private
  * @param {Object} options
  * @param {School} school
  * @param {Http} http
  */
	constructor(options, school, http) {
		const info = _url2.default.parse(school.url);
		if (!/^[^.#\/\\]+\.magister\.net$/.test(info.host)) {
			throw new Error('`school.url` is not a correct magister url');
		}
		school.url = `https://${info.host}`;

		/**
   * @type {Object}
   * @readonly
   * @private
   */
		this._options = options;
		/**
   * @type {School}
   * @readonly
   */
		this.school = _lodash2.default.extend(new _school2.default({}), school);
		/**
   * @type {Http}
   * @readonly
   */
		this.http = http;
		/**
   * @type {ProfileInfo}
   * @readonly
   */
		this.profileInfo = null;
	}

	/**
 	 * @type {String}
 	 * @readonly
 	 */
	get token() {
		return this.http._token;
	}

	/**
  * @return {Promise<Activity[]>}
  */
	activities() {
		return this._privileges.needs('activiteiten', 'read').then(() => this.http.get(`${this._personUrl}/activiteiten`)).then(res => res.json()).then(res => res.Items.map(a => new _activity2.default(this, a)));
	}

	/**
  * @param {Date} from Time is ignored.
  * @param {Date} [to=from] Time is ignored
  * @param {Object} [options={}]
  * 	@param {Boolean} [options.fillPersons=false]
  * 	@param {Boolean} [options.fetchAbsences=true]
  * 	@param {Boolean} [options.ignoreAbsenceErrors=true]
  * @return {Promise<Appointment[]>}
  */
	appointments() {
		// extract options
		var _ref = _lodash2.default.find(arguments, _lodash2.default.isPlainObject) || {},
		    _ref$fillPersons = _ref.fillPersons;

		const fillPersons = _ref$fillPersons === undefined ? false : _ref$fillPersons;
		var _ref$fetchAbsences = _ref.fetchAbsences;
		const fetchAbsences = _ref$fetchAbsences === undefined ? true : _ref$fetchAbsences;
		var _ref$ignoreAbsenceErr = _ref.ignoreAbsenceErrors;
		const ignoreAbsenceErrors = _ref$ignoreAbsenceErr === undefined ? true : _ref$ignoreAbsenceErr;

		// extract dates

		const dates = (0, _lodash2.default)(arguments).filter(_lodash2.default.isDate).sortBy().value();
		const from = dates[0];
		const to = dates[1] || dates[0];

		const fromUrl = util.urlDateConvert(from);
		const toUrl = util.urlDateConvert(to);

		// fetch appointments
		const appointmentsUrl = `${this._personUrl}/afspraken?van=${fromUrl}&tot=${toUrl}`;
		const appointmentsPromise = this._privileges.needs('afspraken', 'read').then(() => this.http.get(appointmentsUrl)).then(res => res.json()).then(res => res.Items.map(a => new _appointment2.default(this, a))).then(appointments => {
			if (!fillPersons) {
				return appointments;
			}

			const promises = appointments.map(a => {
				return Promise.all(a.teachers.map(t => t.getFilled('teacher'))).then(teachers => a.teachers = teachers).then(() => a);
			});
			return Promise.all(promises);
		});

		// fetch absences
		let absencesPromise = Promise.resolve([]);
		if (fetchAbsences) {
			const absencesUrl = `${this._personUrl}/absenties?van=${fromUrl}&tot=${toUrl}`;
			absencesPromise = this._privileges.needs('Absenties', 'read').then(() => this.http.get(absencesUrl)).then(res => res.json()).then(res => res.Items.map(a => new _absenceInfo2.default(this, a)));

			if (ignoreAbsenceErrors) {
				absencesPromise = absencesPromise.catch(() => []);
			}
		}

		return Promise.all([appointmentsPromise, absencesPromise]).then(([appointments, absences]) => {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = appointments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					const a = _step.value;

					a.absenceInfo = absences.find(i => i.appointment.id === a.id);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return appointments;
		}).then(appointments => _lodash2.default.sortBy(appointments, 'start'));
	}

	/**
  * @param {Object} [options={}]
  * 	@param {Number} [options.count=50]
  * 	@param {Number} [options.skip=0]
  * 	@param {Boolean} [options.fillPersons=false]
  * @return {Promise<Assignment[]>}
  */
	assignments({
		count = 50,
		skip = 0,
		fillPersons = false
	} = {}) {
		const url = `${this._personUrl}/opdrachten?top=${count}&skip=${skip}&status=alle`;

		return this._privileges.needs('eloopdracht', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(i => i.Id)).then(ids => {
			const promises = ids.map(id => {
				return this.http.get(`${this._personUrl}/opdrachten/${id}`).then(res => res.json());
			});
			return Promise.all(promises);
		}).then(items => {
			const promises = items.map(item => {
				const assignment = new _assignment2.default(this, item);
				if (!fillPersons) {
					return assignment;
				}

				return Promise.all(assignment.teachers.map(p => p.getFilled('teacher'))).then(teachers => assignment.teachers = teachers).then(() => assignment);
			});
			return Promise.all(promises);
		});
	}

	/**
  * @return {Promise<Magister[]>}
  */
	children() {
		if (this.profileInfo.isChild) {
			return Promise.reject(new Error('User is not a parent'));
		}

		return this.http.get(`${this._personUrl}/kinderen`).then(res => res.json()).then(res => res.Items).then(items => items.map(raw => {
			const m = Object.create(this);

			m.school = this.school;
			m.http = this.http;

			m._personUrl = `${this.school.url}/api/personen/${raw.Id}`;
			m._pupilUrl = `${this.school.url}/api/leerlingen/${raw.Id}`;
			m.profileInfo = new _profileInfo2.default(m, raw);

			return m;
		}));
	}

	/**
  * @return {Promise<Course[]>}
  */
	courses() {
		return this._privileges.needs('aanmeldingen', 'read').then(() => this.http.get(`${this._personUrl}/aanmeldingen`)).then(res => res.json()).then(res => res.Items.map(c => new _course2.default(this, c))).then(items => _lodash2.default.sortBy(items, 'start'));
	}

	/**
  * @param {Object} options
  * 	@param {String} options.description The description of the appointment.
  * 	@param {Date} options.start The start of the appointment, time is
  * 	ignored when `options.fullDay` is set to true.
  * 	@param {Date} options.end The end of the appointment, this is ignored
  * 	when `options.fullDay` is set to true.
  * 	@param {Boolean} [options.fullDay=false] When this is true,
  * 	`options.end` is ignored and only `options.start` is used to set the
  * 	begin and the end for the appointment.
  * 	@param {String} [options.location] The location (classroom for example)
  * 	for the appointment.
  * 	@param {String} [options.content] Some arbitrary string you want to
  * 	save.
  * 	@param {Number} [options.type=1] The type of the appointment: 1 for
  * 	personal or 16 for planning
  * @return {Promise}
  */
	createAppointment(options) {
		const required = ['description', 'start', 'end'];
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = required[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				const key = _step2.value;

				if (options[key] == null) {
					const err = new Error(`Not all required fields for \`options\` are given, required are: [ ${required.join(', ')} ]`);
					return Promise.reject(err);
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		if (options.fullDay) {
			options.start = util.date(options.start);
			options.end = new Date(options.start.getTime()) + 1000 * 60 * 60 * 24;
		}

		const payload = {
			Omschrijving: options.description,
			Start: options.start.toJSON(),
			Einde: options.end.toJSON(),

			Lokatie: _lodash2.default.trim(options.location),
			Inhoud: function () {
				const content = _lodash2.default.trim(options.content);
				return content.length > 0 ? _lodash2.default.escape(content) : null;
			}(),
			Type: options.type || 1,
			DuurtHeleDag: options.fullDay || false,

			// Static non-configurable stuff.
			InfoType: 0,
			WeergaveType: 1,
			Status: 2,
			HeeftBijlagen: false,
			Bijlagen: null,
			LesuurVan: null,
			LesuurTotMet: null,
			Aantekening: null,
			Afgerond: false,
			Vakken: null,
			Docenten: null,
			Links: null,
			Id: 0,
			Lokalen: null,
			Groepen: null,
			OpdrachtId: 0
		};

		return this._privileges.needs('afspraken', 'create').then(() => this.http.post(`${this._personUrl}/afspraken`, payload));
	}

	/**
  * @return {Promise<FileFolder[]>}
  */
	fileFolders() {
		return this._privileges.needs('bronnen', 'read').then(() => this.http.get(`${this._personUrl}/bronnen?soort=0`)).then(res => res.json()).then(res => res.Items.map(f => new _fileFolder2.default(this, f)));
	}

	/**
  * @return {Promise<MessageFolder[]>}
  */
	messageFolders() {
		return this._privileges.needs('berichten', 'read').then(() => this.http.get(`${this._personUrl}/berichten/mappen`)).then(res => res.json()).then(res => res.Items.map(m => new _messageFolder2.default(this, m)));
	}

	/**
  * @param {String} query
  * @param {String} [type]
  * @return {Promise<Person[]>}
  */
	persons(query, type) {
		query = query != null ? query.trim() : '';

		if (query.length < 3) {
			return Promise.resolve([]);
		} else if (type == null) {
			return Promise.all([this.persons(query, 'teacher'), this.persons(query, 'pupil')]).then(([teachers, pupils]) => teachers.concat(pupils));
		}

		type = {
			'teacher': 'Personeel',
			'pupil': 'Leerling',
			'project': 'Project'
		}[type] || 'Overig';
		query = query.replace(/ +/g, '+');

		const url = `${this._personUrl}/contactpersonen?contactPersoonType=${type}&q=${query}`;

		return this._privileges.needs('contactpersonen', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(p => {
			p = new _person2.default(this, p);
			p._filled = true;
			return p;
		}));
	}

	/**
  * @return {Promise<SchoolUtility[]>}
  */
	schoolUtilities() {
		const url = `${this._personUrl}/lesmateriaal`;

		return this._privileges.needs('digitaallesmateriaal', 'read').then(() => this.http.get(url)).then(res => res.json()).then(res => res.Items.map(u => new _schoolUtility2.default(this, u)));
	}

	/**
  * Logins to Magister.
  * @param {Boolean} [forceLogin=false] Force a login, even when a token
  * is in the options object.
  * @return {Promise<String>} A promise that resolves when done logging in. With the current session ID as parameter.
  */
	login(forceLogin = false) {
		var _this = this;

		return _asyncToGenerator(function* () {
			const self = _this;

			const options = _this._options;
			const schoolUrl = _this.school.url;
			const filteredName = schoolUrl.replace('https://', '');

			const randomHash = function randomHash() {
				return (0, _crypto.createHash)('md5').update(Math.random().toString()).digest('hex');
			};

			let authorizeUrl = 'https://accounts.magister.net/connect/authorize';
			authorizeUrl += `?client_id=M6-${filteredName}`;
			authorizeUrl += `&redirect_uri=https%3A%2F%2F${filteredName}%2Foidc%2Fredirect_callback.html`;
			authorizeUrl += '&response_type=id_token%20token';
			authorizeUrl += '&scope=openid%20profile%20magister.ecs.legacy%20magister.mdv.broker.read%20magister.dnn.roles.read';
			authorizeUrl += `&state=${randomHash()}`;
			authorizeUrl += `&nonce=${randomHash()}`;
			authorizeUrl += `&acr_values=tenant%3A${filteredName}`;

			const setToken = function setToken(token) {
				self.http._token = token;
				return token;
			};

			const retrieveAccount = (() => {
				var _ref2 = _asyncToGenerator(function* () {
					const accountData = yield self.http.get(`${schoolUrl}/api/account`).then(function (res) {
						return res.json();
					});
					const id = accountData.Persoon.Id;

					// REVIEW: do we want to make profileInfo a function?
					self.profileInfo = new _profileInfo2.default(self, accountData.Persoon);
					self._privileges = new _privileges2.default(self, accountData.Groep[0].Privileges);

					self._personUrl = `${schoolUrl}/api/personen/${id}`;
					self._pupilUrl = `${schoolUrl}/api/leerlingen/${id}`;
				});

				return function retrieveAccount() {
					return _ref2.apply(this, arguments);
				};
			})();

			if (!forceLogin && options.token) {
				setToken(options.token);
				return yield retrieveAccount();
			}

			// extract returnUrl
			const location = yield _this.http.get(authorizeUrl, {
				redirect: 'manual'
			}).then(function (res) {
				return res.headers.get('Location');
			});

			const returnUrl = decodeURIComponent(location.split('returnUrl=')[1]);

			// extract session and XSRF related stuff
			const xsrfResponse = yield _this.http.get(location, {
				redirect: 'manual'
			});

			const sessionId = xsrfResponse.headers.get('Location').split('?')[1].split('&')[0].split('=')[1];
			const authUrl = 'https://accounts.magister.net/challenge';
			const xsrf = xsrfResponse.headers.get('set-cookie').split('XSRF-TOKEN=')[1].split(';')[0];
			const authCookies = xsrfResponse.headers.get('set-cookie').toString();

			let authRes;
			// test username
			authRes = yield _this.http.post(`${authUrl}/username`, {
				sessionId: sessionId,
				returnUrl: returnUrl,
				username: options.username
			}, {
				headers: {
					Cookie: authCookies,
					'X-XSRF-TOKEN': xsrf
				}
			});
			if (authRes.error || authRes.status !== 200) {
				throw new _authError2.default(authRes.error || 'Invalid username');
			}

			// test password
			authRes = yield _this.http.post(`${authUrl}/password`, {
				sessionId: sessionId,
				returnUrl: returnUrl,
				password: options.password
			}, {
				headers: {
					Cookie: authCookies,
					'X-XSRF-TOKEN': xsrf
				}
			});
			if (authRes.error || authRes.status !== 200) {
				throw new _authError2.default(authRes.error || 'Invalid password');
			}

			// extract bearer token
			const res = yield _this.http.get(`https://accounts.magister.net${returnUrl}`, {
				redirect: 'manual',
				headers: {
					Cookie: authRes.headers.get('set-cookie'),
					'X-XSRF-TOKEN': xsrf
				}
			});
			const tokenRegex = /&access_token=([^&]*)/;
			const loc = res.headers.get('Location');

			setToken(tokenRegex.exec(loc)[1]);
			return yield retrieveAccount();
		})();
	}
}

/**
 * Create a new Magister object using `options`.
 * @param {Object} options
 * 	@param {School} options.school The school to login to.
 * 	@param {String} [options.username] The username of the user to login to.
 * 	@param {String} [options.password] The password of the user to login to.
 * 	@param {String} [options.token] The Bearer token to use. (instead of the username and password)
 * 	@param {Boolean} [options.keepLoggedIn=true] Whether or not to keep the user logged in.
 * 	@param {Boolean} [options.login=true] Whether or not to call {@link login} before returning the object.
 * @return {Promise<Magister>}
 */
function magister(options) {
	_lodash2.default.defaults(options, {
		keepLoggedIn: true,
		login: true
	});
	const rej = s => Promise.reject(new Error(s));

	if (!(options.school && (options.token || options.username && options.password))) {
		return rej('school and username&password or token are required.');
	}

	if (!_lodash2.default.isObject(options.school)) {
		return rej('school is not an object');
	} else if (!_lodash2.default.isString(options.school.url)) {
		return rej('`school.url` is not a string');
	}

	return Promise.resolve().then(() => {
		const m = new Magister(options, options.school, new _http2.default());

		return options.login ? m.login().then(() => m) : m;
	});
}

/**
 * Get the schools matching `query`.
 * @param {String} query
 * @return {Promise<School[]>}
 */
function getSchools(query) {
	query = query.replace(/\d/g, '');
	query = query.trim();
	query = query.replace(/ +/g, '+');

	if (query.length < 3) {
		return Promise.resolve([]);
	}

	return (0, _nodeFetch2.default)(`https://mijn.magister.net/api/schools?filter=${query}`).then(res => res.json()).then(schools => schools.map(school => new _school2.default(school)));
}

/**
 * The version of the library.
 * @type {String}
 * @readonly
 */
const VERSION = exports.VERSION = '2.0.0-alpha.4';
exports.AbsenceInfo = _absenceInfo2.default;
exports.Activity = _activity2.default;
exports.ActivityElement = _activityElement2.default;
exports.AddressInfo = _addressInfo2.default;
exports.Appointment = _appointment2.default;
exports.Assignment = _assignment2.default;
exports.AssignmentVersion = _assignmentVersion2.default;
exports.AuthError = _authError2.default;
exports.Class = _class2.default;
exports.Course = _course2.default;
exports.File = _file2.default;
exports.FileFolder = _fileFolder2.default;
exports.Grade = _grade2.default;
exports.GradePeriod = _gradePeriod2.default;
exports.GradeType = _gradeType2.default;
exports.Magister = Magister;
exports.Message = _message2.default;
exports.MessageFolder = _messageFolder2.default;
exports.Person = _person2.default;
exports.Privileges = _privileges2.default;
exports.ProfileInfo = _profileInfo2.default;
exports.ProfileSettings = _profileSettings2.default;
exports.School = _school2.default;
exports.SchoolUtility = _schoolUtility2.default;
exports.VersionInfo = _versionInfo2.default;
